
import { WebAppTemplate } from '../models/WebAppTemplate';

export type AttackPayload = {
  source: string;
  timestamp: string;
  path: string;
  method: string;
  payload: string;
  headers: Record<string, string>;
};

export type VulnerabilityResponse = {
  statusCode: number;
  headers: Record<string, string>;
  body: string;
  detected: boolean;
  vulnerabilityType: string;
};

export class VulnerabilityEmulator {
  private webApp: WebAppTemplate;
  private enabledVulnerabilities: Record<string, boolean> = {};
  
  constructor(webApp: WebAppTemplate) {
    this.webApp = webApp;
    this.enabledVulnerabilities = {
      'SQL Injection': webApp.vulnerabilityProfile.sql,
      'Cross-Site Scripting (XSS)': webApp.vulnerabilityProfile.xss,
      'Remote File Inclusion': webApp.vulnerabilityProfile.rfi,
      'Local File Inclusion': webApp.vulnerabilityProfile.lfi,
      'Command Injection': webApp.vulnerabilityProfile.commandInjection,
      'CSRF Vulnerabilities': webApp.vulnerabilityProfile.csrf
    };
  }
  
  public setVulnerabilityEnabled(type: string, enabled: boolean): void {
    if (type in this.enabledVulnerabilities) {
      this.enabledVulnerabilities[type] = enabled;
    }
  }
  
  public isVulnerabilityEnabled(type: string): boolean {
    return this.enabledVulnerabilities[type] || false;
  }
  
  public getWebApp(): WebAppTemplate {
    return this.webApp;
  }
  
  public setWebApp(webApp: WebAppTemplate): void {
    this.webApp = webApp;
    // Update enabled vulnerabilities based on new web app profile
    this.enabledVulnerabilities = {
      'SQL Injection': webApp.vulnerabilityProfile.sql,
      'Cross-Site Scripting (XSS)': webApp.vulnerabilityProfile.xss,
      'Remote File Inclusion': webApp.vulnerabilityProfile.rfi,
      'Local File Inclusion': webApp.vulnerabilityProfile.lfi,
      'Command Injection': webApp.vulnerabilityProfile.commandInjection,
      'CSRF Vulnerabilities': webApp.vulnerabilityProfile.csrf
    };
  }
  
  public getVulnerabilityResponse(path: string, payload: string): string {
    // Generate app-specific responses based on the selected web app
    const appName = this.webApp.name;
    
    if (path.includes('wp-') && appName === 'WordPress') {
      return `WordPress error: The database server returned an error. Error: ${payload}`;
    } else if (path.includes('phpmyadmin') && appName === 'PHPMyAdmin') {
      return `phpMyAdmin - Error\n\nSQL query: ${payload}\nMySQL said: #1064 - You have an error in your SQL syntax`;
    } else if ((path.includes('products') || path.includes('cart')) && appName === 'E-commerce') {
      return `Shop Error: Unable to process request. Please contact support. Error code: E-SQLI-${Math.floor(Math.random() * 1000)}`;
    } else {
      return `Application Error: Invalid request detected at ${path}. Security violation logged.`;
    }
  }
  
  public detectAttack(attack: AttackPayload): VulnerabilityResponse | null {
    // Skip if the targeted vulnerability is disabled
    const vulnerabilityType = this.identifyVulnerabilityType(attack);
    if (!vulnerabilityType || !this.enabledVulnerabilities[vulnerabilityType]) {
      return null;
    }
    
    // Customize response based on web app type and vulnerability
    let responseBody = this.getVulnerabilityResponse(attack.path, attack.payload);
    
    return {
      statusCode: this.getAppropriateStatusCode(vulnerabilityType),
      headers: this.getAppropriateHeaders(this.webApp.name),
      body: responseBody,
      detected: true,
      vulnerabilityType
    };
  }
  
  private identifyVulnerabilityType(attack: AttackPayload): string | null {
    const payload = attack.payload.toLowerCase();
    
    if (payload.includes("'") && (payload.includes("select") || payload.includes("union") || payload.includes("or 1=1"))) {
      return 'SQL Injection';
    } else if (payload.includes("<script") || payload.includes("onerror") || payload.includes("javascript:")) {
      return 'Cross-Site Scripting (XSS)';
    } else if (payload.includes("http://") && (payload.includes(".php") || payload.includes(".js"))) {
      return 'Remote File Inclusion';
    } else if (payload.includes("../") || payload.includes("etc/passwd")) {
      return 'Local File Inclusion';
    } else if (payload.includes(";") && (payload.includes("cat ") || payload.includes("ls ") || payload.includes("wget"))) {
      return 'Command Injection';
    } else if (attack.headers["referer"] && attack.method === "POST") {
      return 'CSRF Vulnerabilities';
    }
    
    return null;
  }
  
  private getAppropriateStatusCode(vulnerabilityType: string): number {
    switch (vulnerabilityType) {
      case 'SQL Injection':
      case 'Command Injection':
        return 500;
      case 'Cross-Site Scripting (XSS)':
        return 200;
      case 'Remote File Inclusion':
      case 'Local File Inclusion':
        return 404;
      default:
        return 400;
    }
  }
  
  private getAppropriateHeaders(appType: string): Record<string, string> {
    const baseHeaders = {
      'Content-Type': 'text/html',
      'Server': 'Apache/2.4.41'
    };
    
    switch (appType) {
      case 'WordPress':
        return {
          ...baseHeaders,
          'X-Powered-By': 'PHP/7.4.3',
          'Set-Cookie': 'wordpress_logged_in=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT'
        };
      case 'PHPMyAdmin':
        return {
          ...baseHeaders,
          'X-Powered-By': 'PHP/7.2.34',
          'Expires': '0',
          'Pragma': 'no-cache'
        };
      case 'E-commerce':
        return {
          ...baseHeaders,
          'X-Powered-By': 'PHP/8.0.8',
          'X-Shop-Version': '3.0.1'
        };
      default:
        return baseHeaders;
    }
  }
}
